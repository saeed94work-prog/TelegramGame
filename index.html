<!doctype html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover" />
  <title>Space Rush — Telegram Mini Game</title>

  <style>
    :root{
      --bg0:#050713;
      --bg1:#0b1030;
      --panel:rgba(255,255,255,.06);
      --text:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.68);
      --neon:#35f0ff;
      --danger:#ff3b6b;
      --gold:#ffd166;
      --ok:#35ff9a;
      --shadow: 0 10px 32px rgba(0,0,0,.48);
      --radius:16px;
    }
    *{box-sizing:border-box; -webkit-tap-highlight-color:transparent;}
    html,body{height:100%; margin:0; background: radial-gradient(1100px 800px at 50% 18%, #142066 0%, var(--bg0) 55%, #04050c 100%);
      color:var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;}
    .wrap{height:100%; display:grid; grid-template-rows:auto 1fr auto; padding:12px; gap:10px; max-width:820px; margin:0 auto;}
    .topbar{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      padding:12px 14px; border-radius: var(--radius);
      background: var(--panel); box-shadow: var(--shadow); backdrop-filter: blur(10px);
      border:1px solid rgba(255,255,255,.08);
    }
    .brand{display:flex; flex-direction:column; gap:2px}
    .brand b{letter-spacing:.4px}
    .brand small{color:var(--muted); line-height:1.35}

    .stats{display:flex; gap:8px; align-items:center; flex-wrap:wrap; justify-content:flex-end}
    .pill{
      padding:8px 10px; border-radius:999px; background: rgba(255,255,255,.07);
      display:flex; gap:8px; align-items:center; min-width:118px; justify-content:space-between;
      border:1px solid rgba(255,255,255,.08);
    }
    .pill span{color:var(--muted); font-size:12px}
    .pill b{font-variant-numeric: tabular-nums;}

    .stage{
      position:relative; border-radius: var(--radius); overflow:hidden; box-shadow: var(--shadow);
      border: 1px solid rgba(255,255,255,.10);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      min-height: 340px;
    }
    .stage::before{content:""; display:block; padding-top: 177.777%;} /* 16/9 */
    canvas{
      position:absolute; inset:0;
      width:100%;
      height:100%;
      display:block;
      background:#050814;
      touch-action:none;
    }

    .hud{position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none;}
    .card{
      pointer-events:auto;
      width:min(620px, calc(100% - 24px));
      background: rgba(9,11,20,.82);
      border:1px solid rgba(255,255,255,.12);
      border-radius: 18px;
      padding:16px;
      backdrop-filter: blur(10px);
      box-shadow: var(--shadow);
    }
    .card h2{margin:0 0 6px; font-size:18px}
    .card p{margin:0 0 12px; color:var(--muted); line-height:1.7; font-size:13px}
    .grid{display:grid; gap:10px; grid-template-columns: 1fr 1fr}
    button{
      border:0; border-radius: 14px; padding:12px 12px; font-weight:800;
      background: linear-gradient(135deg, rgba(53,240,255,.96), rgba(90,120,255,.96));
      color:#06101a; cursor:pointer; box-shadow: 0 10px 26px rgba(53,240,255,.22);
    }
    button.secondary{
      background: rgba(255,255,255,.08); color:var(--text);
      box-shadow:none; border:1px solid rgba(255,255,255,.12);
    }
    button.danger{
      background: linear-gradient(135deg, rgba(255,59,107,.95), rgba(255,132,74,.95));
      color:#14070b;
      box-shadow: 0 10px 26px rgba(255,59,107,.16);
    }

    .kbd{border:1px solid rgba(255,255,255,.12); border-bottom-width:2px; padding:3px 8px; border-radius:10px; color:var(--text); background: rgba(255,255,255,.06)}
    .row{display:flex; gap:10px; align-items:center; justify-content:space-between; flex-wrap:wrap}
    .toggle{
      display:flex; align-items:center; gap:10px; justify-content:space-between;
      padding:10px 12px; border-radius: 14px;
      background: rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.10);
      margin-top:10px;
    }
    .toggle label{color:var(--muted); font-size:13px}
    .toggle input{width:42px; height:22px}

    .select{
      margin-top:10px;
      padding:10px 12px; border-radius: 14px;
      background: rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.10);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    select{
      background: rgba(255,255,255,.08);
      color: var(--text);
      border:1px solid rgba(255,255,255,.14);
      border-radius: 10px;
      padding:8px 10px;
      outline:none;
    }

    .lb{
      margin-top:10px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.10);
      overflow:hidden;
    }
    .lb table{width:100%; border-collapse:collapse; font-variant-numeric:tabular-nums;}
    .lb th,.lb td{padding:10px 10px; font-size:13px; text-align:right}
    .lb th{color:var(--muted); background: rgba(255,255,255,.06)}
    .lb tr:nth-child(even) td{background: rgba(255,255,255,.03)}
    .lb td:nth-child(1){width:60px; color:rgba(255,255,255,.78)}
    .lb td:nth-child(3){text-align:left; color:rgba(255,255,255,.78)}

    .footer{
      display:flex; gap:10px; align-items:center; justify-content:space-between; flex-wrap:wrap;
      padding:10px 14px; border-radius: var(--radius);
      background: rgba(255,255,255,.04); border:1px solid rgba(255,255,255,.06);
      color:var(--muted); font-size:12px;
    }
    .hide{display:none !important;}
  </style>
</head>

<body>
  <div class="wrap">
    <div class="topbar">
      <div class="brand">
        <b>Space Rush</b>
        <small>پرواز کن، شلیک کن، از شهاب‌سنگ‌ها و دشمن‌ها رد شو</small>
      </div>
      <div class="stats">
        <div class="pill"><span>Score</span><b id="uiScore">0</b></div>
        <div class="pill"><span>Best</span><b id="uiBest">0</b></div>
        <div class="pill"><span>Level</span><b id="uiLevel">1</b></div>
        <div class="pill"><span>HP</span><b id="uiHp">3</b></div>
      </div>
    </div>

    <div class="stage">
      <canvas id="game"></canvas>

      <div class="hud" id="overlay">
        <div class="card" id="cardHome">
          <h2>شروع</h2>
          <p>
            کنترل: <span class="kbd">لمس و کشیدن</span> (آزاد) یا کیبورد <span class="kbd">WASD</span>/<span class="kbd">↑↓←→</span>.
            شلیک: <span class="kbd">Space</span> یا <span class="kbd">Double Tap</span>.
            <br/>هرچی بیشتر زنده بمونی Level و موج دشمن‌ها سخت‌تر می‌شه.
          </p>
          <div class="grid">
            <button id="btnPlay">Play</button>
            <button class="secondary" id="btnSettings">Settings</button>
          </div>
          <p style="margin-top:10px;color:var(--muted)">
            Pause: <span class="kbd">P</span> — Leaderboard: <span class="kbd">L</span>
          </p>
        </div>

        <div class="card hide" id="cardSettings">
          <h2>Settings</h2>
          <p>تنظیمات روی دستگاه ذخیره می‌شن. لیدربورد آنلاین اگر بک‌اند وصل باشد فعال می‌شود.</p>

          <div class="toggle">
            <label for="tglMute">Sound (Mute)</label>
            <input id="tglMute" type="checkbox" />
          </div>

          <div class="toggle">
            <label for="tglHaptics">Haptics (Vibration)</label>
            <input id="tglHaptics" type="checkbox" checked />
          </div>

          <div class="select">
            <label for="selQuality" style="color:var(--muted); font-size:13px">Quality</label>
            <select id="selQuality">
              <option value="1">High</option>
              <option value="0.85">Medium</option>
              <option value="0.7">Low</option>
            </select>
          </div>

          <div class="select">
            <label for="inpApi" style="color:var(--muted); font-size:13px">Leaderboard API base URL</label>
            <input id="inpApi" style="flex:1; min-width:180px; padding:10px 10px; border-radius:10px; border:1px solid rgba(255,255,255,.14); background:rgba(255,255,255,.06); color:var(--text); outline:none"
              placeholder="https://your-domain.com"
            />
          </div>

          <div class="grid" style="margin-top:12px">
            <button class="secondary" id="btnBackHome">Back</button>
            <button id="btnPlay2">Play</button>
          </div>
        </div>

        <div class="card hide" id="cardOver">
          <h2>Game Over</h2>
          <p id="txtOver">—</p>
          <div class="grid">
            <button id="btnRetry">Retry</button>
            <button class="secondary" id="btnLeaderboard">Leaderboard</button>
          </div>
          <div class="grid" style="margin-top:10px">
            <button class="secondary" id="btnShare">Share score</button>
            <button class="danger" id="btnSubmit">Submit score</button>
          </div>
        </div>

        <div class="card hide" id="cardLB">
          <h2>Leaderboard</h2>
          <p id="lbHint">—</p>
          <div class="lb">
            <table>
              <thead><tr><th>#</th><th>Player</th><th>Score</th></tr></thead>
              <tbody id="lbBody"></tbody>
            </table>
          </div>
          <div class="grid" style="margin-top:12px">
            <button class="secondary" id="btnCloseLB">Close</button>
            <button id="btnRefreshLB">Refresh</button>
          </div>
        </div>
      </div>
    </div>

    <div class="footer">
      <div>
        <span class="kbd">Touch</span>
        <span class="kbd">WASD</span>
        <span class="kbd">Space</span> Shoot
      </div>
      <div id="tgState">Telegram: not detected</div>
    </div>
  </div>

  <script>
    // Optional Telegram WebApp integration
    const TG = window.Telegram && window.Telegram.WebApp ? window.Telegram.WebApp : null;
    document.getElementById("tgState").textContent = TG ? "Telegram: WebApp ready" : "Telegram: not detected";
    if (TG) { try { TG.ready(); TG.expand(); } catch {} }

    // UI
    const uiScore = document.getElementById("uiScore");
    const uiBest  = document.getElementById("uiBest");
    const uiLevel = document.getElementById("uiLevel");
    const uiHp    = document.getElementById("uiHp");

    const overlay = document.getElementById("overlay");
    const cardHome = document.getElementById("cardHome");
    const cardSettings = document.getElementById("cardSettings");
    const cardOver = document.getElementById("cardOver");
    const cardLB = document.getElementById("cardLB");

    const txtOver = document.getElementById("txtOver");
    const lbHint = document.getElementById("lbHint");
    const lbBody = document.getElementById("lbBody");

    const btnPlay = document.getElementById("btnPlay");
    const btnPlay2 = document.getElementById("btnPlay2");
    const btnSettings = document.getElementById("btnSettings");
    const btnBackHome = document.getElementById("btnBackHome");
    const btnRetry = document.getElementById("btnRetry");
    const btnShare = document.getElementById("btnShare");
    const btnSubmit = document.getElementById("btnSubmit");
    const btnLeaderboard = document.getElementById("btnLeaderboard");
    const btnCloseLB = document.getElementById("btnCloseLB");
    const btnRefreshLB = document.getElementById("btnRefreshLB");

    const tglMute = document.getElementById("tglMute");
    const tglHaptics = document.getElementById("tglHaptics");
    const selQuality = document.getElementById("selQuality");
    const inpApi = document.getElementById("inpApi");

    // Settings
    const SETTINGS_KEY = "spacerush_settings_v1";
    const defaultSettings = {
      mute:false,
      haptics:true,
      quality:1,
      apiBase:""
    };
    const settings = loadSettings();
    tglMute.checked = settings.mute;
    tglHaptics.checked = settings.haptics;
    selQuality.value = String(settings.quality);
    inpApi.value = settings.apiBase || "";

    function loadSettings(){
      try{
        const raw = localStorage.getItem(SETTINGS_KEY);
        if (!raw) return {...defaultSettings};
        const obj = JSON.parse(raw);
        return {...defaultSettings, ...obj};
      }catch{
        return {...defaultSettings};
      }
    }
    function saveSettings(){
      settings.mute = !!tglMute.checked;
      settings.haptics = !!tglHaptics.checked;
      settings.quality = Number(selQuality.value || 1);
      settings.apiBase = (inpApi.value || "").trim();
      localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
      resizeCanvas();
    }
    tglMute.addEventListener("change", saveSettings);
    tglHaptics.addEventListener("change", saveSettings);
    selQuality.addEventListener("change", saveSettings);
    inpApi.addEventListener("change", saveSettings);

    // Sound (no assets)
    let audioCtx = null;
    function beep(freq=440, dur=0.05, type="sine", gain=0.03){
      if (settings.mute) return;
      try{
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const t0 = audioCtx.currentTime;
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = type;
        o.frequency.value = freq;
        g.gain.value = gain;
        o.connect(g); g.connect(audioCtx.destination);
        o.start(t0);
        o.stop(t0 + dur);
      }catch{}
    }
    function haptic(kind){
      if (!settings.haptics) return;
      if (TG) { try { TG.HapticFeedback.impactOccurred(kind || "light"); } catch {} }
    }

    // Canvas responsive with virtual resolution + letterbox
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const V = { w: 720, h: 1280 }; // virtual design space
    const S = { scale:1, ox:0, oy:0, vw:V.w, vh:V.h };

    function resizeCanvas(){
      const rect = canvas.getBoundingClientRect();
      const dpr = (window.devicePixelRatio || 1) * (settings.quality || 1);
      canvas.width  = Math.max(1, Math.floor(rect.width * dpr));
      canvas.height = Math.max(1, Math.floor(rect.height * dpr));
      ctx.setTransform(dpr,0,0,dpr,0,0);

      const rw = rect.width, rh = rect.height;
      const s = Math.min(rw / V.w, rh / V.h);
      S.scale = s;
      S.vw = V.w * s;
      S.vh = V.h * s;
      S.ox = (rw - S.vw) / 2;
      S.oy = (rh - S.vh) / 2;
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    function toVirtual(clientX, clientY){
      const rect = canvas.getBoundingClientRect();
      const x = clientX - rect.left;
      const y = clientY - rect.top;
      return {
        x: (x - S.ox) / S.scale,
        y: (y - S.oy) / S.scale
      };
    }

    // Helpers
    const clamp = (v,a,b)=>Math.max(a, Math.min(b, v));
    const rnd = (a,b)=>a + Math.random()*(b-a);

    function beginScene(){
      const rect = canvas.getBoundingClientRect();
      ctx.clearRect(0,0,rect.width,rect.height);

      // background outside playfield
      const bg = ctx.createLinearGradient(0,0,0,rect.height);
      bg.addColorStop(0, "rgba(18,28,80,.28)");
      bg.addColorStop(1, "rgba(0,0,0,.45)");
      ctx.fillStyle = bg;
      ctx.fillRect(0,0,rect.width,rect.height);

      // clip to playfield
      ctx.save();
      ctx.translate(S.ox, S.oy);
      ctx.beginPath();
      ctx.rect(0,0,S.vw,S.vh);
      ctx.clip();
      ctx.scale(S.scale, S.scale);
    }
    function endScene(){ ctx.restore(); }

    function glowCircle(x,y,r,color,alpha=1, blur=18){
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.shadowColor = color;
      ctx.shadowBlur = blur;
      ctx.fillStyle = color;
      ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
      ctx.restore();
    }

    function circleHit(ax,ay,ar, bx,by,br){
      const dx = ax-bx, dy = ay-by;
      return (dx*dx + dy*dy) <= (ar+br)*(ar+br);
    }

    // Meteor (irregular polygon) generator
    function makeMeteorShape(radius){
      const pts = [];
      const n = Math.floor(rnd(8, 13));
      for (let i=0; i<n; i++){
        const ang = (i/n) * Math.PI*2;
        const rr = radius * rnd(0.72, 1.10);
        pts.push({ x: Math.cos(ang)*rr, y: Math.sin(ang)*rr });
      }
      return pts;
    }

    function drawMeteor(m){
      // trail
      ctx.save();
      ctx.globalAlpha = 0.25;
      ctx.strokeStyle = "rgba(255,140,74,.8)";
      ctx.lineWidth = 10;
      ctx.lineCap = "round";
      ctx.beginPath();
      ctx.moveTo(m.x, m.y + m.r*1.2);
      ctx.lineTo(m.x, m.y + m.r*4.2);
      ctx.stroke();
      ctx.restore();

      // body
      ctx.save();
      ctx.translate(m.x, m.y);
      ctx.rotate(m.rot);
      ctx.shadowColor = "rgba(255,120,79,.95)";
      ctx.shadowBlur = 22;

      const g = ctx.createRadialGradient(-m.r*0.2, -m.r*0.3, m.r*0.2, 0, 0, m.r*1.2);
      g.addColorStop(0, "#b7773a");
      g.addColorStop(1, "#5a3a20");
      ctx.fillStyle = g;

      ctx.beginPath();
      const pts = m.shape;
      ctx.moveTo(pts[0].x, pts[0].y);
      for (let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x, pts[i].y);
      ctx.closePath();
      ctx.fill();

      // cracks
      ctx.globalAlpha = 0.22;
      ctx.strokeStyle = "rgba(255,255,255,.85)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(-m.r*0.6, -m.r*0.1);
      ctx.lineTo(m.r*0.5, m.r*0.35);
      ctx.stroke();

      ctx.restore();
    }

    function drawShip(p){
      // engine glow
      ctx.save();
      ctx.globalAlpha = 0.45;
      ctx.fillStyle = "rgba(53,240,255,.45)";
      ctx.beginPath();
      ctx.ellipse(p.x, p.y + p.r*1.25, p.r*0.55, p.r*1.2, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();

      // body (simple spaceship)
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.shadowColor = "rgba(53,240,255,.95)";
      ctx.shadowBlur = 18;

      // hull
      const hull = ctx.createLinearGradient(0,-p.r,0,p.r);
      hull.addColorStop(0, "rgba(255,255,255,.95)");
      hull.addColorStop(1, "rgba(53,240,255,.75)");
      ctx.fillStyle = hull;

      ctx.beginPath();
      ctx.moveTo(0, -p.r*1.35);
      ctx.quadraticCurveTo(p.r*0.95, -p.r*0.15, p.r*0.55, p.r*1.15);
      ctx.quadraticCurveTo(0, p.r*0.75, -p.r*0.55, p.r*1.15);
      ctx.quadraticCurveTo(-p.r*0.95, -p.r*0.15, 0, -p.r*1.35);
      ctx.closePath();
      ctx.fill();

      // canopy
      ctx.globalAlpha = 0.9;
      ctx.fillStyle = "rgba(18,30,55,.85)";
      ctx.beginPath();
      ctx.ellipse(0, -p.r*0.25, p.r*0.45, p.r*0.62, 0, 0, Math.PI*2);
      ctx.fill();

      ctx.restore();
    }

    // Parallax layers
    const layers = [
      { speed: 18, stars: [] },
      { speed: 42, stars: [] },
      { speed: 86, stars: [] },
    ];
    function initParallax(){
      for (const L of layers){
        L.stars = Array.from({length: 70}, ()=>({
          x: Math.random()*V.w,
          y: Math.random()*V.h,
          s: rnd(0.8, 2.4),
          a: rnd(0.25, 0.85)
        }));
      }
    }
    initParallax();

    function updateParallax(dt, speedMul){
      for (const L of layers){
        for (const s of L.stars){
          s.y += L.speed * dt * speedMul;
          if (s.y > V.h + 10){
            s.y = -10;
            s.x = Math.random()*V.w;
            s.s = rnd(0.8, 2.4);
            s.a = rnd(0.25, 0.85);
          }
        }
      }
    }

    function drawParallax(){
      ctx.save();
      for (let i=0;i<layers.length;i++){
        const L = layers[i];
        ctx.globalAlpha = 0.65;
        ctx.fillStyle = i === 0 ? "rgba(255,255,255,.85)" : i === 1 ? "rgba(170,200,255,.85)" : "rgba(255,255,255,.75)";
        for (const s of L.stars){
          ctx.globalAlpha = s.a;
          ctx.fillRect(s.x, s.y, s.s, s.s);
        }
      }
      ctx.restore();

      // nebula fog
      ctx.save();
      const g = ctx.createRadialGradient(V.w*0.55, V.h*0.25, 20, V.w*0.55, V.h*0.25, V.w*0.85);
      g.addColorStop(0, "rgba(90,120,255,.12)");
      g.addColorStop(1, "rgba(0,0,0,0)");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,V.w,V.h);
      ctx.restore();
    }

    // Game state
    let running=false, paused=false, gameOver=false;

    let score=0;
    let level=1;
    let timeAlive=0;

    let best = Number(localStorage.getItem("spacerush_best_v1") || 0);
    uiBest.textContent = String(best);

    const player = {
      x: V.w*0.5,
      y: V.h*0.78,
      targetX: V.w*0.5,
      targetY: V.h*0.78,
      r: 20,
      speed: 980,
      hp: 3,
      inv: 0 // invulnerability seconds
    };

    const meteors = [];   // obstacles
    const bullets = [];   // player bullets
    const enemies = [];   // enemy ships
    const eBullets = [];  // enemy bullets
    const particles = []; // explosions

    // Shooting cooldown
    let shootCd = 0;
    const SHOOT_DELAY = 0.22;

    // Spawners
    let tMeteor=0;
    let tEnemy=0;

    function resetGame(){
      running=true; paused=false; gameOver=false;
      score=0; level=1; timeAlive=0;
      player.x = V.w*0.5;
      player.y = V.h*0.78;
      player.targetX = player.x;
      player.targetY = player.y;
      player.hp = 3;
      player.inv = 0;

      meteors.length=0;
      bullets.length=0;
      enemies.length=0;
      eBullets.length=0;
      particles.length=0;

      shootCd = 0;
      tMeteor = 0;
      tEnemy = 0;

      uiScore.textContent = "0";
      uiLevel.textContent = "1";
      uiHp.textContent = "3";
    }

    function spawnMeteor(){
      const r = rnd(18, 42);
      meteors.push({
        x: rnd(r+12, V.w-r-12),
        y: -rnd(60, 240),
        r,
        vy: 260 + level*55 + rnd(-20, 60),
        vx: rnd(-80, 80),
        rot: rnd(0, Math.PI*2),
        rotSp: rnd(-2.6, 2.6),
        shape: makeMeteorShape(r),
      });
    }

    function spawnEnemy(){
      const r = 22;
      const side = Math.random() < 0.5 ? -1 : 1;
      enemies.push({
        x: side < 0 ? -60 : V.w + 60,
        y: rnd(120, V.h*0.42),
        r,
        vx: side < 0 ? rnd(180, 260) : -rnd(180, 260),
        vy: rnd(-35, 35),
        hp: 4 + Math.floor(level/3),
        phase: rnd(0, Math.PI*2),
        fireCd: rnd(0.3, 1.2),
      });
    }

    function explode(x,y, color="rgba(255,209,102,.9)", count=14){
      for (let i=0;i<count;i++){
        particles.push({
          x,y,
          vx: rnd(-220, 220),
          vy: rnd(-220, 220),
          r: rnd(1.5, 4.2),
          a: 1,
          life: rnd(0.25, 0.65),
          color
        });
      }
    }

    function shoot(){
      if (shootCd > 0 || paused || gameOver || !running) return;
      shootCd = SHOOT_DELAY;

      bullets.push({
        x: player.x,
        y: player.y - player.r*1.2,
        r: 4.5,
        vy: -980,
      });

      beep(720, 0.03, "square", 0.02);
      haptic("light");
    }

    // Input
    const keys = { up:false, down:false, left:false, right:false };

    window.addEventListener("keydown", (e)=>{
      const k = e.key.toLowerCase();
      if (k === "arrowleft" || k === "a") keys.left = true;
      if (k === "arrowright" || k === "d") keys.right = true;
      if (k === "arrowup" || k === "w") keys.up = true;
      if (k === "arrowdown" || k === "s") keys.down = true;

      if (e.code === "Space") shoot();
      if (k === "p") togglePause();
      if (k === "l") openLeaderboard();
    });
    window.addEventListener("keyup", (e)=>{
      const k = e.key.toLowerCase();
      if (k === "arrowleft" || k === "a") keys.left = false;
      if (k === "arrowright" || k === "d") keys.right = false;
      if (k === "arrowup" || k === "w") keys.up = false;
      if (k === "arrowdown" || k === "s") keys.down = false;
    });

    let dragging=false;
    let lastTapT = 0;

    canvas.addEventListener("pointerdown", (e)=>{
      dragging=true;
      canvas.setPointerCapture(e.pointerId);

      const now = performance.now();
      if (now - lastTapT < 260) shoot(); // double tap
      lastTapT = now;

      const p = toVirtual(e.clientX, e.clientY);
      player.targetX = clamp(p.x, player.r+10, V.w-player.r-10);
      player.targetY = clamp(p.y, V.h*0.30, V.h-player.r-10);
    });
    canvas.addEventListener("pointermove", (e)=>{
      if (!dragging) return;
      const p = toVirtual(e.clientX, e.clientY);
      player.targetX = clamp(p.x, player.r+10, V.w-player.r-10);
      player.targetY = clamp(p.y, V.h*0.30, V.h-player.r-10);
    });
    canvas.addEventListener("pointerup", ()=> dragging=false);
    canvas.addEventListener("pointercancel", ()=> dragging=false);

    // UI navigation
    btnPlay.onclick = start;
    btnPlay2.onclick = start;
    btnRetry.onclick = start;

    btnSettings.onclick = ()=>{
      cardHome.classList.add("hide");
      cardOver.classList.add("hide");
      cardLB.classList.add("hide");
      cardSettings.classList.remove("hide");
      overlay.classList.remove("hide");
      overlay.style.pointerEvents = "auto";
    };
    btnBackHome.onclick = ()=>{
      cardSettings.classList.add("hide");
      cardOver.classList.add("hide");
      cardLB.classList.add("hide");
      cardHome.classList.remove("hide");
      overlay.classList.remove("hide");
      overlay.style.pointerEvents = "auto";
    };

    btnLeaderboard.onclick = openLeaderboard;
    btnCloseLB.onclick = ()=>{
      cardLB.classList.add("hide");
      cardOver.classList.remove("hide");
      overlay.classList.remove("hide");
      overlay.style.pointerEvents = "auto";
    };
    btnRefreshLB.onclick = ()=> refreshLeaderboard();

    btnShare.onclick = ()=>{
      const msg = `Space Rush — Score: ${Math.floor(score)} | Best: ${best} | Level: ${level}`;
      if (TG) {
        try { TG.sendData(JSON.stringify({ type:"share", text:msg, score:Math.floor(score), best, level })); } catch {}
      } else {
        try { navigator.clipboard.writeText(msg); } catch {}
        alert("متن رکورد کپی شد:\n\n" + msg);
      }
    };

    btnSubmit.onclick = async ()=>{
      const ok = await submitScoreOnline(Math.floor(score));
      if (ok) {
        beep(880, 0.06, "triangle", 0.03);
        haptic("light");
        await refreshLeaderboard();
        openLeaderboard();
      } else {
        alert("Submit نشد. یا API تنظیم نیست یا بک‌اند در دسترس نیست.");
      }
    };

    function togglePause(){
      if (!running || gameOver) return;
      paused = !paused;
      beep(paused ? 220 : 520, 0.05, "square", 0.02);
      haptic("light");
    }

    function start(){
      saveSettings();
      resetGame();

      overlay.classList.add("hide");
      overlay.style.pointerEvents = "none";

      lastT = performance.now();
      requestAnimationFrame(loop);

      beep(740, 0.06, "sine", 0.03);
      haptic("light");
    }

    // Leaderboard: online + offline fallback
    function getPlayerIdentity(){
      if (TG && TG.initDataUnsafe && TG.initDataUnsafe.user){
        const u = TG.initDataUnsafe.user;
        const name = (u.username ? "@"+u.username : [u.first_name, u.last_name].filter(Boolean).join(" ")).trim() || ("user-"+u.id);
        return { userId: String(u.id), name };
      }
      const anonIdKey = "spacerush_anon_id";
      let id = localStorage.getItem(anonIdKey);
      if (!id){
        id = String(Math.floor(Math.random()*1e9)) + "-" + String(Date.now());
        localStorage.setItem(anonIdKey, id);
      }
      return { userId: id, name: "Guest" };
    }

    async function submitScoreOnline(finalScore){
      const base = (settings.apiBase || "").replace(/\/+$/,"");
      if (!base) return false;

      const me = getPlayerIdentity();
      const body = {
        userId: me.userId,
        username: me.name,
        score: finalScore,
        // initData: TG ? TG.initData : "" // اگر خواستی سرور verify کنه
      };

      try{
        const res = await fetch(base + "/submit-score", {
          method:"POST",
          headers:{ "Content-Type":"application/json" },
          body: JSON.stringify(body)
        });
        return res.ok;
      }catch{
        return false;
      }
    }

    function offlineSubmit(finalScore){
      const KEY = "spacerush_offline_lb";
      const me = getPlayerIdentity();
      const row = { userId: me.userId, username: me.name, score: finalScore };

      let list = [];
      try { list = JSON.parse(localStorage.getItem(KEY) || "[]"); } catch {}
      // keep best per user
      const idx = list.findIndex(x => x.userId === row.userId);
      if (idx >= 0) list[idx].score = Math.max(list[idx].score, row.score);
      else list.push(row);

      list.sort((a,b)=>b.score-a.score);
      list = list.slice(0, 20);
      localStorage.setItem(KEY, JSON.stringify(list));
      return list;
    }

    async function fetchLeaderboard(){
      const base = (settings.apiBase || "").replace(/\/+$/,"");
      if (!base) return null;
      try{
        const res = await fetch(base + "/leaderboard?limit=20", { method:"GET" });
        if (!res.ok) return null;
        const data = await res.json();
        if (!Array.isArray(data)) return null;
        return data;
      }catch{
        return null;
      }
    }

    async function refreshLeaderboard(){
      // try online
      const online = await fetchLeaderboard();
      if (online){
        lbHint.textContent = "Online leaderboard";
        renderLeaderboard(online);
        return;
      }
      // fallback
      lbHint.textContent = "Offline leaderboard (API not available)";
      const list = offlineSubmit(best);
      renderLeaderboard(list);
    }

    function renderLeaderboard(list){
      lbBody.innerHTML = "";
      const rows = list.slice(0, 20);
      for (let i=0;i<rows.length;i++){
        const r = rows[i] || {};
        const tr = document.createElement("tr");

        const td1 = document.createElement("td"); td1.textContent = String(i+1);
        const td2 = document.createElement("td"); td2.textContent = String(r.username || "—");
        const td3 = document.createElement("td"); td3.textContent = String(r.score ?? "—");

        tr.appendChild(td1); tr.appendChild(td2); tr.appendChild(td3);
        lbBody.appendChild(tr);
      }
    }

    async function openLeaderboard(){
      overlay.classList.remove("hide");
      overlay.style.pointerEvents = "auto";
      cardHome.classList.add("hide");
      cardSettings.classList.add("hide");
      cardOver.classList.add("hide");
      cardLB.classList.remove("hide");
      await refreshLeaderboard();
    }

    // Main loop
    let lastT = performance.now();

    function loop(t){
      if (!running) return;
      const dt = Math.min(0.033, (t - lastT)/1000);
      lastT = t;

      if (!paused && !gameOver) update(dt);
      draw(dt);

      requestAnimationFrame(loop);
    }

    function update(dt){
      timeAlive += dt;

      const newLevel = 1 + Math.floor(timeAlive / 16);
      if (newLevel !== level){
        level = newLevel;
        uiLevel.textContent = String(level);
        beep(620, 0.05, "triangle", 0.02);
        haptic("light");
      }

      // speed multiplier to make parallax feel alive
      const speedMul = 1 + level*0.06;
      updateParallax(dt, speedMul);

      // cooldowns
      shootCd = Math.max(0, shootCd - dt);
      player.inv = Math.max(0, player.inv - dt);

      // keyboard steering adjusts target
      const kx = (keys.right?1:0) - (keys.left?1:0);
      const ky = (keys.down?1:0) - (keys.up?1:0);
      if (kx || ky){
        player.targetX += kx * dt * 700;
        player.targetY += ky * dt * 700;
        player.targetX = clamp(player.targetX, player.r+10, V.w-player.r-10);
        player.targetY = clamp(player.targetY, V.h*0.30, V.h-player.r-10);
      }

      // smooth follow
      const dx = player.targetX - player.x;
      const dy = player.targetY - player.y;
      const maxStep = player.speed * dt;
      player.x += clamp(dx, -maxStep, maxStep);
      player.y += clamp(dy, -maxStep, maxStep);

      // score tick
      score += dt * (48 + level*8);
      uiScore.textContent = String(Math.floor(score));

      // spawn meteor
      tMeteor -= dt;
      const meteorRate = clamp(0.55 - level*0.02, 0.12, 0.55);
      if (tMeteor <= 0){
        tMeteor = meteorRate * rnd(0.85, 1.15);
        spawnMeteor();
        if (level >= 4 && Math.random() < 0.35) spawnMeteor();
        if (level >= 7 && Math.random() < 0.25) spawnMeteor();
      }

      // spawn enemies
      tEnemy -= dt;
      const enemyRate = clamp(3.6 - level*0.12, 1.3, 3.6);
      if (tEnemy <= 0){
        tEnemy = enemyRate * rnd(0.9, 1.15);
        spawnEnemy();
        if (level >= 6 && Math.random() < 0.35) spawnEnemy();
      }

      // update meteors
      for (let i=meteors.length-1; i>=0; i--){
        const m = meteors[i];
        m.y += m.vy * dt;
        m.x += m.vx * dt;
        m.rot += m.rotSp * dt;

        if (m.x < -80) m.x = V.w + 80;
        if (m.x > V.w + 80) m.x = -80;

        if (m.y > V.h + 200) meteors.splice(i, 1);
        else if (player.inv <= 0 && circleHit(player.x, player.y, player.r*0.95, m.x, m.y, m.r*0.92)){
          damagePlayer(1);
          explode(m.x, m.y, "rgba(255,140,74,.9)", 16);
          meteors.splice(i,1);
        }
      }

      // update bullets
      for (let i=bullets.length-1; i>=0; i--){
        const b = bullets[i];
        b.y += b.vy * dt;
        if (b.y < -80) bullets.splice(i,1);
      }

      // update enemies (smart-ish)
      for (let i=enemies.length-1; i>=0; i--){
        const e = enemies[i];
        e.phase += dt * 2.4;

        // smooth tracking toward player.y area, with zigzag x
        const desiredY = clamp(player.y + Math.sin(e.phase)*70, 110, V.h*0.58);
        e.y += (desiredY - e.y) * dt * 0.9;

        const desiredX = clamp(player.x + Math.sin(e.phase)*160, 60, V.w-60);
        e.x += (desiredX - e.x) * dt * 0.75;

        // firing
        e.fireCd -= dt;
        if (e.fireCd <= 0){
          e.fireCd = rnd(0.55, 0.95) * clamp(1.15 - level*0.03, 0.55, 1.15);

          // aim at player
          const ax = player.x - e.x;
          const ay = player.y - e.y;
          const len = Math.hypot(ax, ay) || 1;
          const sp = 420 + level*18;

          eBullets.push({
            x: e.x, y: e.y + e.r*0.6,
            r: 4.5,
            vx: (ax/len) * sp,
            vy: (ay/len) * sp
          });

          beep(260, 0.04, "sawtooth", 0.02);
        }

        // bullet collisions on enemy
        for (let bi=bullets.length-1; bi>=0; bi--){
          const b = bullets[bi];
          if (circleHit(b.x, b.y, b.r, e.x, e.y, e.r*0.95)){
            bullets.splice(bi,1);
            e.hp -= 1;
            explode(b.x, b.y, "rgba(53,240,255,.9)", 10);
            beep(520, 0.03, "square", 0.02);
            if (e.hp <= 0){
              enemies.splice(i,1);
              score += 800 + level*90;
              explode(e.x, e.y, "rgba(255,209,102,.9)", 22);
              haptic("light");
            }
            break;
          }
        }

        // player collision with enemy
        if (i < enemies.length && player.inv <= 0 && circleHit(player.x, player.y, player.r*0.95, e.x, e.y, e.r*0.95)){
          damagePlayer(2);
          explode(e.x, e.y, "rgba(255,59,107,.9)", 22);
          enemies.splice(i,1);
        }
      }

      // update enemy bullets
      for (let i=eBullets.length-1; i>=0; i--){
        const b = eBullets[i];
        b.x += b.vx * dt;
        b.y += b.vy * dt;
        if (b.y > V.h+120 || b.y < -120 || b.x < -120 || b.x > V.w+120){
          eBullets.splice(i,1);
          continue;
        }
        if (player.inv <= 0 && circleHit(player.x, player.y, player.r*0.9, b.x, b.y, b.r)){
          eBullets.splice(i,1);
          damagePlayer(1);
          explode(b.x, b.y, "rgba(255,59,107,.9)", 14);
        }
      }

      // update particles
      for (let i=particles.length-1; i>=0; i--){
        const p = particles[i];
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.vx *= (1 - dt*2.2);
        p.vy *= (1 - dt*2.2);
        p.life -= dt;
        p.a = Math.max(0, p.life / 0.65);
        if (p.life <= 0) particles.splice(i,1);
      }
    }

    function damagePlayer(amount){
      player.hp -= amount;
      player.inv = 0.95;
      uiHp.textContent = String(Math.max(0, player.hp));

      beep(140, 0.10, "sawtooth", 0.035);
      haptic("medium");

      if (player.hp <= 0){
        endGame();
      }
    }

    function endGame(){
      gameOver = true;
      running = false;

      const finalScore = Math.floor(score);
      if (finalScore > best){
        best = finalScore;
        localStorage.setItem("spacerush_best_v1", String(best));
        uiBest.textContent = String(best);
      }

      // always keep offline LB fresh
      offlineSubmit(best);

      txtOver.textContent =
        `امتیاز: ${finalScore}\nرکورد: ${best}\nلول: ${level}\n\nنکته: Space/DoubleTap تیر می‌زنه، حرکت آزاد دو بعدی.`

      overlay.classList.remove("hide");
      overlay.style.pointerEvents = "auto";
      cardOver.classList.remove("hide");
      cardHome.classList.add("hide");
      cardSettings.classList.add("hide");
      cardLB.classList.add("hide");

      beep(110, 0.12, "sawtooth", 0.04);
      haptic("heavy");
    }

    function draw(dt){
      beginScene();

      // space background
      drawParallax();

      // subtle vignette
      ctx.save();
      const vg = ctx.createRadialGradient(V.w*0.5, V.h*0.55, V.h*0.15, V.w*0.5, V.h*0.55, V.h*0.9);
      vg.addColorStop(0, "rgba(0,0,0,0)");
      vg.addColorStop(1, "rgba(0,0,0,.28)");
      ctx.fillStyle = vg;
      ctx.fillRect(0,0,V.w,V.h);
      ctx.restore();

      // meteors
      for (const m of meteors) drawMeteor(m);

      // enemies
      for (const e of enemies){
        glowCircle(e.x, e.y, e.r*1.05, "rgba(255,59,107,.85)", 0.42, 22);
        ctx.save();
        ctx.translate(e.x, e.y);
        ctx.shadowColor = "rgba(255,59,107,.9)";
        ctx.shadowBlur = 18;
        ctx.fillStyle = "rgba(255,59,107,.92)";
        ctx.beginPath();
        ctx.moveTo(0, -e.r*1.1);
        ctx.lineTo(e.r*0.95, e.r*0.9);
        ctx.lineTo(-e.r*0.95, e.r*0.9);
        ctx.closePath();
        ctx.fill();

        // eye
        ctx.globalAlpha = 0.85;
        ctx.fillStyle = "rgba(10,10,18,.75)";
        ctx.beginPath();
        ctx.ellipse(0, 0, e.r*0.35, e.r*0.28, 0, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }

      // bullets
      for (const b of bullets){
        glowCircle(b.x, b.y, b.r, "rgba(53,240,255,.95)", 0.9, 16);
        glowCircle(b.x, b.y, b.r*0.6, "rgba(255,255,255,.95)", 0.5, 8);
      }

      // enemy bullets
      for (const b of eBullets){
        glowCircle(b.x, b.y, b.r, "rgba(255,59,107,.95)", 0.85, 16);
        glowCircle(b.x, b.y, b.r*0.6, "rgba(255,255,255,.9)", 0.35, 8);
      }

      // ship (blink when invulnerable)
      if (player.inv > 0 && Math.floor(performance.now()/90)%2 === 0){
        // skip draw to blink
      } else {
        drawShip(player);
      }

      // particles
      for (const p of particles){
        ctx.save();
        ctx.globalAlpha = p.a;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x,p.y,p.r,0,Math.PI*2);
        ctx.fill();
        ctx.restore();
      }

      // pause overlay
      if (paused){
        ctx.save();
        ctx.fillStyle = "rgba(0,0,0,.45)";
        ctx.fillRect(0,0,V.w,V.h);
        ctx.fillStyle = "rgba(255,255,255,.92)";
        ctx.font = "900 54px ui-sans-serif, system-ui";
        ctx.textAlign = "center";
        ctx.fillText("PAUSED", V.w/2, V.h/2 - 10);
        ctx.font = "600 22px ui-sans-serif, system-ui";
        ctx.fillStyle = "rgba(255,255,255,.75)";
        ctx.fillText("Press P to resume", V.w/2, V.h/2 + 30);
        ctx.restore();
      }

      endScene();
    }

    // Overlay initial
    overlay.classList.remove("hide");

    // Also allow submit & leaderboard by keyboard even after game ends
    window.addEventListener("keydown", (e)=>{
      if (e.key.toLowerCase() === "l") openLeaderboard();
    });
  </script>

  <!-- Optional. If you include this, Telegram features get more reliable in some environments -->
  <!-- <script src="https://telegram.org/js/telegram-web-app.js"></script> -->
</body>
</html>

<!doctype html>
<html lang="fa">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover" />
  <title>Neon Dodger — Telegram Game</title>
  <style>
    :root{
      --bg:#070A12;
      --panel:rgba(255,255,255,.06);
      --text:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.65);
      --neon:#35f0ff;
      --danger:#ff3b6b;
      --ok:#35ff9a;
      --shadow: 0 10px 30px rgba(0,0,0,.45);
      --radius:16px;
    }
    *{box-sizing:border-box; -webkit-tap-highlight-color:transparent;}
    html,body{height:100%; margin:0; background: radial-gradient(1200px 800px at 50% 20%, #121a3a 0%, var(--bg) 55%, #05070e 100%); color:var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;}
    .wrap{height:100%; display:grid; grid-template-rows:auto 1fr auto; padding:14px; gap:12px; max-width:720px; margin:0 auto;}
    .topbar{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      padding:12px 14px; border-radius: var(--radius);
      background: var(--panel); box-shadow: var(--shadow); backdrop-filter: blur(10px);
    }
    .brand{display:flex; flex-direction:column; gap:2px}
    .brand b{letter-spacing:.4px}
    .brand small{color:var(--muted)}
    .stats{display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:flex-end}
    .pill{
      padding:8px 10px; border-radius:999px; background: rgba(255,255,255,.07);
      display:flex; gap:8px; align-items:center; min-width:120px; justify-content:space-between;
      border:1px solid rgba(255,255,255,.06);
    }
    .pill span{color:var(--muted); font-size:12px}
    .pill b{font-variant-numeric: tabular-nums;}
    .stage{
      position:relative; border-radius: var(--radius); overflow:hidden; box-shadow: var(--shadow);
      border: 1px solid rgba(255,255,255,.08);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
    }
    canvas{display:block; width:100%; height:auto; background: #060814;}
    .hud{
      position:absolute; inset:0; pointer-events:none;
      display:flex; align-items:center; justify-content:center;
    }
    .card{
      pointer-events:auto;
      width:min(520px, calc(100% - 28px));
      background: rgba(10,12,20,.78);
      border:1px solid rgba(255,255,255,.10);
      border-radius: 18px;
      padding:16px;
      backdrop-filter: blur(10px);
      box-shadow: var(--shadow);
    }
    .card h2{margin:0 0 6px; font-size:18px}
    .card p{margin:0 0 12px; color:var(--muted); line-height:1.6; font-size:13px}
    .grid{display:grid; gap:10px; grid-template-columns: 1fr 1fr}
    button{
      border:0; border-radius: 14px; padding:12px 12px; font-weight:700;
      background: linear-gradient(135deg, rgba(53,240,255,.95), rgba(90,120,255,.95));
      color:#06101a; cursor:pointer; box-shadow: 0 10px 26px rgba(53,240,255,.22);
    }
    button.secondary{
      background: rgba(255,255,255,.08); color:var(--text);
      box-shadow:none; border:1px solid rgba(255,255,255,.10);
    }
    .footer{
      display:flex; gap:10px; align-items:center; justify-content:space-between; flex-wrap:wrap;
      padding:10px 14px; border-radius: var(--radius);
      background: rgba(255,255,255,.04); border:1px solid rgba(255,255,255,.06);
      color:var(--muted); font-size:12px;
    }
    .controls{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
    .kbd{border:1px solid rgba(255,255,255,.12); border-bottom-width:2px; padding:3px 8px; border-radius:10px; color:var(--text); background: rgba(255,255,255,.06)}
    .hide{display:none !important;}
    .hint{color:var(--muted)}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div class="brand">
        <b>Neon Dodger</b>
        <small>فرار کن، امتیاز بگیر، رکورد بزن</small>
      </div>
      <div class="stats">
        <div class="pill"><span>Score</span><b id="score">0</b></div>
        <div class="pill"><span>Best</span><b id="best">0</b></div>
        <div class="pill"><span>Level</span><b id="level">1</b></div>
      </div>
    </div>

    <div class="stage">
      <canvas id="game" width="720" height="960"></canvas>

      <div class="hud" id="overlay">
        <div class="card" id="startCard">
          <h2>شروع بازی</h2>
          <p>
            با <span class="kbd">لمس و کشیدن</span> یا کلیدهای <span class="kbd">←</span> <span class="kbd">→</span> حرکت کن.
            هرچقدر بیشتر زنده بمونی امتیاز و سرعت بیشتر می‌شه.
          </p>
          <div class="grid">
            <button id="btnStart">Start</button>
            <button class="secondary" id="btnHow">How to play</button>
          </div>
          <p class="hint" style="margin-top:10px">برای تلگرام: بازی داخل Web App عالی اجرا می‌شود.</p>
        </div>

        <div class="card hide" id="howCard">
          <h2>راهنما</h2>
          <p>
            هدف: از برخورد با موانع قرمز جلوگیری کن. ستاره‌ها امتیاز اضافه می‌دهند.
            هر 20 ثانیه یک Level بالا می‌رود و سرعت بیشتر می‌شود.
          </p>
          <div class="grid">
            <button class="secondary" id="btnBack">Back</button>
            <button id="btnStart2">Start</button>
          </div>
        </div>

        <div class="card hide" id="overCard">
          <h2>Game Over</h2>
          <p id="overText">—</p>
          <div class="grid">
            <button id="btnRetry">Retry</button>
            <button class="secondary" id="btnShare">Share score</button>
          </div>
        </div>
      </div>
    </div>

    <div class="footer">
      <div class="controls">
        <span class="kbd">Touch</span>
        <span class="kbd">← →</span>
        <span class="kbd">P</span> Pause
      </div>
      <div id="tgState">Telegram: not detected</div>
    </div>
  </div>

  <script>
    // Telegram WebApp integration (safe optional)
    const TG = window.Telegram && window.Telegram.WebApp ? window.Telegram.WebApp : null;
    const tgState = document.getElementById("tgState");
    if (TG) {
      tgState.textContent = "Telegram: WebApp ready";
      try { TG.ready(); TG.expand(); } catch {}
    }

    // Canvas & scale
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const uiScore = document.getElementById("score");
    const uiBest  = document.getElementById("best");
    const uiLevel = document.getElementById("level");

    const overlay  = document.getElementById("overlay");
    const startCard= document.getElementById("startCard");
    const howCard  = document.getElementById("howCard");
    const overCard = document.getElementById("overCard");
    const overText = document.getElementById("overText");

    const btnStart = document.getElementById("btnStart");
    const btnHow   = document.getElementById("btnHow");
    const btnBack  = document.getElementById("btnBack");
    const btnStart2= document.getElementById("btnStart2");
    const btnRetry = document.getElementById("btnRetry");
    const btnShare = document.getElementById("btnShare");

    // Fixed internal resolution; rendered responsive via CSS width:100%
    const W = canvas.width, H = canvas.height;

    // Game state
    let running = false;
    let paused = false;
    let gameOver = false;

    let score = 0;
    let best = Number(localStorage.getItem("neon_best") || 0);
    uiBest.textContent = best.toString();

    let level = 1;
    let timeAlive = 0;

    const rnd = (a,b)=>a + Math.random()*(b-a);
    const clamp = (v,a,b)=>Math.max(a, Math.min(b, v));

    // Player
    const player = {
      x: W*0.5,
      y: H*0.82,
      r: 18,
      vx: 0,
      speed: 900, // px/s responsiveness
    };

    // Entities
    const obstacles = [];
    const stars = [];

    function resetGame(){
      running = true; paused = false; gameOver = false;
      score = 0; level = 1; timeAlive = 0;
      player.x = W*0.5; player.vx = 0;
      obstacles.length = 0;
      stars.length = 0;
      uiScore.textContent = "0";
      uiLevel.textContent = "1";
    }

    function spawnObstacle(){
      const w = rnd(42, 90);
      const x = rnd(w*0.8, W - w*0.8);
      const y = -rnd(60, 220);
      const speed = 260 + level*55 + rnd(-20, 40);
      obstacles.push({ x, y, w, h: w*1.1, speed });
    }

    function spawnStar(){
      const x = rnd(24, W-24);
      const y = -rnd(80, 360);
      const speed = 230 + level*45 + rnd(-20, 20);
      stars.push({ x, y, r: 10, speed, pulse: rnd(0, Math.PI*2) });
    }

    let obstacleTimer = 0;
    let starTimer = 0;

    // Input: keyboard + touch drag
    const keys = { left:false, right:false };

    window.addEventListener("keydown", (e)=>{
      if (e.key === "ArrowLeft") keys.left = true;
      if (e.key === "ArrowRight") keys.right = true;
      if (e.key.toLowerCase() === "p") togglePause();
      if (e.key === " " && !running) start();
    });
    window.addEventListener("keyup", (e)=>{
      if (e.key === "ArrowLeft") keys.left = false;
      if (e.key === "ArrowRight") keys.right = false;
    });

    let dragging = false;
    let lastX = 0;

    canvas.addEventListener("pointerdown", (e)=>{
      dragging = true;
      lastX = e.clientX;
      canvas.setPointerCapture(e.pointerId);
    });
    canvas.addEventListener("pointermove", (e)=>{
      if (!dragging) return;
      const dx = e.clientX - lastX;
      lastX = e.clientX;

      // Convert screen dx to internal dx roughly by relative scale
      const rect = canvas.getBoundingClientRect();
      const scale = W / rect.width;
      player.x += dx * scale;
      player.x = clamp(player.x, player.r+18, W - player.r-18);
    });
    canvas.addEventListener("pointerup", ()=> dragging = false);
    canvas.addEventListener("pointercancel", ()=> dragging = false);

    // Buttons
    btnHow.onclick = ()=>{ startCard.classList.add("hide"); howCard.classList.remove("hide"); };
    btnBack.onclick = ()=>{ howCard.classList.add("hide"); startCard.classList.remove("hide"); };
    btnStart.onclick = start;
    btnStart2.onclick = start;
    btnRetry.onclick = start;

    btnShare.onclick = ()=>{
      const text = `Neon Dodger — Score: ${Math.floor(score)} (Best: ${best})`;
      if (TG) {
        try { TG.sendData(JSON.stringify({ type:"share", text, score:Math.floor(score), best })); } catch {}
      } else {
        try { navigator.clipboard.writeText(text); } catch {}
        showinfo("کپی شد", "متن رکورد در کلیپ‌بورد کپی شد.");
      }
    };

    function showinfo(title, msg){
      alert(title + "\n\n" + msg);
    }

    function togglePause(){
      if (!running || gameOver) return;
      paused = !paused;
      if (TG) { try { TG.HapticFeedback.impactOccurred("light"); } catch {} }
    }

    function start(){
      resetGame();
      overlay.style.pointerEvents = "none";
      startCard.classList.add("hide");
      howCard.classList.add("hide");
      overCard.classList.add("hide");
      overlay.classList.add("hide");
      requestAnimationFrame(loop);
      if (TG) { try { TG.HapticFeedback.notificationOccurred("success"); } catch {} }
    }

    // Rendering helpers
    function glowCircle(x,y,r,color,alpha=1){
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.shadowColor = color;
      ctx.shadowBlur = 18;
      ctx.fillStyle = color;
      ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
      ctx.restore();
    }

    function roundedRect(x,y,w,h,r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }

    function intersectsCircleRect(cx, cy, cr, rx, ry, rw, rh){
      const nx = clamp(cx, rx, rx+rw);
      const ny = clamp(cy, ry, ry+rh);
      const dx = cx - nx, dy = cy - ny;
      return (dx*dx + dy*dy) <= cr*cr;
    }

    // Background stars
    const bg = Array.from({length:120}, ()=>({x:Math.random()*W, y:Math.random()*H, r:rnd(0.6,1.6), s:rnd(10,60)}));

    // Main loop
    let lastT = performance.now();

    function loop(t){
      if (!running) return;
      const dt = Math.min(0.033, (t - lastT)/1000);
      lastT = t;

      if (!paused && !gameOver) update(dt);
      draw(dt);

      requestAnimationFrame(loop);
    }

    function update(dt){
      timeAlive += dt;

      // Level up every 20s
      const newLevel = 1 + Math.floor(timeAlive / 20);
      if (newLevel !== level){
        level = newLevel;
        uiLevel.textContent = String(level);
        if (TG) { try { TG.HapticFeedback.notificationOccurred("success"); } catch {} }
      }

      // Score increases with time & level
      score += dt * (35 + level*6);
      uiScore.textContent = String(Math.floor(score));

      // Keyboard movement (smooth)
      const dir = (keys.right?1:0) - (keys.left?1:0);
      player.vx = dir * player.speed;
      player.x += player.vx * dt;
      player.x = clamp(player.x, player.r+18, W - player.r-18);

      // Spawning
      obstacleTimer -= dt;
      starTimer -= dt;

      const obstacleRate = clamp(0.65 - level*0.03, 0.22, 0.65);
      const starRate = 1.05;

      if (obstacleTimer <= 0){
        obstacleTimer = obstacleRate * rnd(0.85, 1.15);
        spawnObstacle();
        if (level >= 5 && Math.random() < 0.35) spawnObstacle();
      }
      if (starTimer <= 0){
        starTimer = starRate * rnd(0.9, 1.2);
        if (Math.random() < 0.85) spawnStar();
      }

      // Update obstacles
      for (let i=obstacles.length-1; i>=0; i--){
        const o = obstacles[i];
        o.y += o.speed * dt;
        if (o.y > H + 140) obstacles.splice(i,1);
        else if (intersectsCircleRect(player.x, player.y, player.r, o.x - o.w/2, o.y - o.h/2, o.w, o.h)){
          endGame();
          return;
        }
      }

      // Update stars
      for (let i=stars.length-1; i>=0; i--){
        const s = stars[i];
        s.y += s.speed * dt;
        s.pulse += dt*5;
        if (s.y > H + 140) stars.splice(i,1);
        else {
          const dx = s.x - player.x, dy = s.y - player.y;
          if (dx*dx + dy*dy <= (s.r + player.r + 6)**2){
            score += 120 + level*15;
            stars.splice(i,1);
            if (TG) { try { TG.HapticFeedback.impactOccurred("light"); } catch {} }
          }
        }
      }
    }

    function endGame(){
      gameOver = true;
      running = false;

      const finalScore = Math.floor(score);
      if (finalScore > best){
        best = finalScore;
        localStorage.setItem("neon_best", String(best));
        uiBest.textContent = String(best);
      }

      overText.textContent =
        `Score: ${finalScore}\nBest: ${best}\nLevel: ${level}\n\nنکته: با لمس و کشیدن کنترل دقیق‌تره.`;

      overlay.classList.remove("hide");
      overlay.style.pointerEvents = "auto";
      overCard.classList.remove("hide");
      startCard.classList.add("hide");
      howCard.classList.add("hide");

      if (TG) { try { TG.HapticFeedback.notificationOccurred("error"); } catch {} }
    }

    function draw(dt){
      // Background
      ctx.clearRect(0,0,W,H);

      // Subtle gradient
      const g = ctx.createLinearGradient(0,0,0,H);
      g.addColorStop(0, "rgba(20,40,80,.25)");
      g.addColorStop(1, "rgba(0,0,0,.35)");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,W,H);

      // Moving bg stars
      ctx.save();
      ctx.globalAlpha = 0.9;
      ctx.fillStyle = "rgba(255,255,255,.75)";
      for (const p of bg){
        p.y += p.s * dt * (1 + level*0.05);
        if (p.y > H) { p.y = -10; p.x = Math.random()*W; p.r = rnd(0.6,1.6); p.s = rnd(10,60); }
        ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill();
      }
      ctx.restore();

      // Lane glow
      ctx.save();
      ctx.globalAlpha = 0.35;
      ctx.strokeStyle = "rgba(53,240,255,.35)";
      ctx.lineWidth = 2;
      for (let i=1; i<=3; i++){
        const x = (W/4)*i;
        ctx.setLineDash([10, 16]);
        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
      }
      ctx.setLineDash([]);
      ctx.restore();

      // Obstacles
      for (const o of obstacles){
        const x = o.x - o.w/2, y = o.y - o.h/2;
        ctx.save();
        ctx.shadowColor = "rgba(255,59,107,.9)";
        ctx.shadowBlur = 18;
        ctx.fillStyle = "rgba(255,59,107,.95)";
        roundedRect(x, y, o.w, o.h, 14);
        ctx.fill();
        ctx.restore();

        // highlight
        ctx.save();
        ctx.globalAlpha = 0.3;
        ctx.fillStyle = "rgba(255,255,255,.9)";
        roundedRect(x+8, y+8, o.w-16, 10, 8);
        ctx.fill();
        ctx.restore();
      }

      // Stars
      for (const s of stars){
        const a = 0.75 + Math.sin(s.pulse)*0.2;
        glowCircle(s.x, s.y, s.r, "#ffd166", a);
        glowCircle(s.x, s.y, s.r*0.55, "#fff", 0.65);
      }

      // Player
      glowCircle(player.x, player.y, player.r, "#35f0ff", 0.95);
      glowCircle(player.x, player.y, player.r*0.55, "#ffffff", 0.55);

      // Pause overlay
      if (paused){
        ctx.save();
        ctx.fillStyle = "rgba(0,0,0,.45)";
        ctx.fillRect(0,0,W,H);
        ctx.fillStyle = "rgba(255,255,255,.92)";
        ctx.font = "700 44px ui-sans-serif, system-ui";
        ctx.textAlign = "center";
        ctx.fillText("PAUSED", W/2, H/2 - 10);
        ctx.font = "500 20px ui-sans-serif, system-ui";
        ctx.fillStyle = "rgba(255,255,255,.75)";
        ctx.fillText("Press P to resume", W/2, H/2 + 28);
        ctx.restore();
      }
    }

    // Show start screen
    overlay.classList.remove("hide");
  </script>

  <!-- Optional Telegram script if you want (safe to omit): -->
  <!-- <script src="https://telegram.org/js/telegram-web-app.js"></script> -->
</body>
</html>
